{"version":3,"file":"vue-slicksort.min.js","sources":["../src/ElementMixin.ts","../src/Manager.ts","../src/utils.ts","../src/ContainerMixin.ts","../src/HandleDirective.ts","../src/components/SlickItem.ts","../src/components/SlickList.ts","../src/components/DragHandle.ts","../src/SlicksortHub.ts","../src/plugin.ts"],"sourcesContent":["import { defineComponent } from 'vue';\nimport Manager, { ItemRef } from './Manager';\n\ninterface ComponentData {\n  manager: Manager;\n  ref: ItemRef;\n}\n\n// Export Sortable Element Component Mixin\nexport const ElementMixin = defineComponent({\n  inject: ['manager'],\n  props: {\n    index: {\n      type: Number,\n      required: true,\n    },\n    disabled: {\n      type: Boolean,\n      default: false,\n    },\n  },\n\n  data() {\n    return ({} as unknown) as ComponentData;\n  },\n\n  watch: {\n    index(newIndex) {\n      if (this.$el && this.$el.sortableInfo) {\n        this.$el.sortableInfo.index = newIndex;\n      }\n    },\n    disabled(isDisabled) {\n      if (isDisabled) {\n        this.removeDraggable();\n      } else {\n        this.setDraggable(this.index);\n      }\n    },\n  },\n\n  mounted() {\n    const { disabled, index } = this.$props;\n\n    if (!disabled) {\n      this.setDraggable(index);\n    }\n  },\n\n  beforeUnmount() {\n    if (!this.disabled) this.removeDraggable();\n  },\n\n  methods: {\n    setDraggable(index: number) {\n      const node = this.$el;\n\n      node.sortableInfo = {\n        index,\n        manager: this.manager,\n      };\n\n      this.ref = { node };\n      this.manager.add(this.ref);\n    },\n\n    removeDraggable() {\n      this.manager.remove(this.ref);\n    },\n  },\n});\n","import { TopLeft } from './utils';\n\nexport interface SortableNode extends HTMLElement {\n  sortableInfo: {\n    index: number;\n    manager: Manager;\n  };\n  sortableHandle?: boolean;\n}\n\nexport interface ItemRef {\n  node: SortableNode;\n  index?: number;\n  edgeOffset?: TopLeft | null;\n}\n\nexport default class Manager {\n  private refs: ItemRef[] = [];\n  public active: { index: number } | null = null;\n\n  add(ref: ItemRef): void {\n    if (!this.refs) {\n      this.refs = [];\n    }\n\n    this.refs.push(ref);\n  }\n\n  remove(ref: ItemRef): void {\n    const index = this.getIndex(ref);\n\n    if (index !== -1) {\n      this.refs.splice(index, 1);\n    }\n  }\n\n  isActive(): boolean {\n    return !!this.active;\n  }\n\n  getActive(): ItemRef | null {\n    return this.refs.find(({ node }) => node?.sortableInfo?.index == this?.active?.index) || null;\n  }\n\n  getIndex(ref: ItemRef): number {\n    return this.refs.indexOf(ref);\n  }\n\n  getRefs(): ItemRef[] {\n    return this.refs;\n  }\n\n  getOrderedRefs(): ItemRef[] {\n    return this.refs.sort((a, b) => {\n      return a.node.sortableInfo.index - b.node.sortableInfo.index;\n    });\n  }\n}\n","import { ItemRef, SortableNode } from './Manager';\n\nexport type XY = { x: number; y: number };\n\nexport type TopLeft = { top: number; left: number };\nexport type BottomRight = { bottom: number; right: number };\nexport type WidthHeight = { width: number; height: number };\nexport type Timer = ReturnType<typeof setTimeout>;\nexport type PointEventName =\n  | 'mousedown'\n  | 'mousemove'\n  | 'mouseup'\n  | 'touchstart'\n  | 'touchmove'\n  | 'touchend'\n  | 'touchcancel';\nexport type PointEvent = MouseEvent | TouchEvent;\n\nexport const isTouch = (e: Event): e is TouchEvent => {\n  return (e as TouchEvent).touches != null;\n};\n\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport function hasOwnProperty<X extends object, Y extends PropertyKey>(\n  obj: X | null,\n  prop: Y,\n): obj is X & Record<Y, unknown> {\n  return !!obj && Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nexport function arrayMove<T>(arr: T[], previousIndex: number, newIndex: number): (T | undefined)[] {\n  const array: (T | undefined)[] = arr.slice(0);\n  if (newIndex >= array.length) {\n    let k = newIndex - array.length;\n    while (k-- + 1) {\n      array.push(undefined);\n    }\n  }\n  array.splice(newIndex, 0, array.splice(previousIndex, 1)[0]);\n  return array;\n}\n\nexport function arrayRemove<T>(arr: T[], previousIndex: number): T[] {\n  const array = arr.slice(0);\n  if (previousIndex >= array.length) return array;\n  array.splice(previousIndex, 1);\n  return array;\n}\n\nexport function arrayInsert<T>(arr: T[], newIndex: number, value: T): T[] {\n  const array = arr.slice(0);\n  if (newIndex === array.length) {\n    array.push(value);\n  } else {\n    array.splice(newIndex, 0, value);\n  }\n  return array;\n}\n\nexport const events: Record<string, string[]> = {\n  start: ['touchstart', 'mousedown'],\n  move: ['touchmove', 'mousemove'],\n  end: ['touchend', 'mouseup'],\n  cancel: ['touchcancel', 'keyup'],\n};\n\nexport function closest(\n  el: SortableNode | Node | null,\n  fn: (el: SortableNode | Node) => boolean,\n): SortableNode | Node | undefined {\n  while (el) {\n    if (fn(el)) return el;\n    el = el.parentNode;\n  }\n}\n\nexport function limit(min: number, max: number, value: number): number {\n  if (value < min) {\n    return min;\n  }\n  if (value > max) {\n    return max;\n  }\n  return value;\n}\n\nfunction getCSSPixelValue(stringValue: string): number {\n  if (stringValue.substr(-2) === 'px') {\n    return parseFloat(stringValue);\n  }\n  return 0;\n}\n\nexport function getElementMargin(element: HTMLElement): TopLeft & BottomRight {\n  const style = window.getComputedStyle(element);\n\n  return {\n    top: getCSSPixelValue(style.marginTop),\n    right: getCSSPixelValue(style.marginRight),\n    bottom: getCSSPixelValue(style.marginBottom),\n    left: getCSSPixelValue(style.marginLeft),\n  };\n}\n\nexport function getPointerOffset(e: PointEvent, reference: 'client' | 'page' = 'page'): XY {\n  const x = `${reference}X` as 'clientX' | 'pageX';\n  const y = `${reference}Y` as 'clientY' | 'pageY';\n\n  return {\n    x: isTouch(e) ? e.touches[0][x] : e[x],\n    y: isTouch(e) ? e.touches[0][y] : e[y],\n  };\n}\n\nfunction offsetParents(node: HTMLElement) {\n  const nodes = [node];\n  for (; node; node = node.offsetParent as HTMLElement) {\n    nodes.unshift(node);\n  }\n  return nodes;\n}\n\nexport function commonOffsetParent(node1: HTMLElement, node2: HTMLElement): HTMLElement | undefined {\n  const parents1 = offsetParents(node1);\n  const parents2 = offsetParents(node2);\n\n  if (parents1[0] != parents2[0]) throw 'No common ancestor!';\n\n  for (let i = 0; i < parents1.length; i++) {\n    if (parents1[i] != parents2[i]) return parents1[i - 1];\n  }\n}\n\nexport function getEdgeOffset(\n  node: HTMLElement,\n  container: HTMLElement,\n  offset = { top: 0, left: 0 },\n): { top: number; left: number } {\n  // Get the actual offsetTop / offsetLeft value, no matter how deep the node is nested\n  if (node) {\n    const nodeOffset = {\n      top: offset.top + node.offsetTop,\n      left: offset.left + node.offsetLeft,\n    };\n    if (node.offsetParent !== container.offsetParent) {\n      return getEdgeOffset(node.offsetParent as HTMLElement, container, nodeOffset);\n    } else {\n      return nodeOffset;\n    }\n  }\n  return { top: 0, left: 0 };\n}\n\nexport function cloneNode(node: HTMLElement): HTMLElement {\n  const fields = node.querySelectorAll('input, textarea, select') as NodeListOf<HTMLInputElement>;\n  const clonedNode = node.cloneNode(true) as HTMLElement;\n  const clonedFields = [...clonedNode.querySelectorAll('input, textarea, select')] as HTMLInputElement[]; // Convert NodeList to Array\n\n  clonedFields.forEach((field, index) => {\n    if (field.type !== 'file' && fields[index]) {\n      field.value = fields[index].value;\n    }\n  });\n\n  return clonedNode;\n}\n\nexport function getLockPixelOffsets(lockOffset: string | number | number[], width: number, height: number): XY[] {\n  if (typeof lockOffset == 'string') {\n    lockOffset = +lockOffset;\n  }\n\n  if (!Array.isArray(lockOffset)) {\n    lockOffset = [lockOffset, lockOffset];\n  }\n\n  if (lockOffset.length !== 2) {\n    throw new Error(\n      `lockOffset prop of SortableContainer should be a single value or an array of exactly two values. Given ${lockOffset}`,\n    );\n  }\n\n  const [minLockOffset, maxLockOffset] = lockOffset;\n\n  return [getLockPixelOffset(minLockOffset, width, height), getLockPixelOffset(maxLockOffset, width, height)];\n}\n\nexport function getLockPixelOffset(lockOffset: number, width: number, height: number): XY {\n  let offsetX = lockOffset;\n  let offsetY = lockOffset;\n  let unit = 'px';\n\n  if (typeof lockOffset === 'string') {\n    const match = /^[+-]?\\d*(?:\\.\\d*)?(px|%)$/.exec(lockOffset);\n\n    if (match === null) {\n      throw new Error(\n        `lockOffset value should be a number or a string of a number followed by \"px\" or \"%\". Given ${lockOffset}`,\n      );\n    }\n\n    offsetX = offsetY = parseFloat(lockOffset);\n    unit = match[1];\n  }\n\n  if (!isFinite(offsetX) || !isFinite(offsetY)) {\n    throw new Error(`lockOffset value should be a finite. Given ${lockOffset}`);\n  }\n\n  if (unit === '%') {\n    offsetX = (offsetX * width) / 100;\n    offsetY = (offsetY * height) / 100;\n  }\n\n  return {\n    x: offsetX,\n    y: offsetY,\n  };\n}\n\nexport function getDistance(x1: number, y1: number, x2: number, y2: number): number {\n  const x = x1 - x2;\n  const y = y1 - y2;\n  return Math.sqrt(x * x + y * y);\n}\n\nexport function getRectCenter(clientRect: ClientRect): XY {\n  return {\n    x: clientRect.left + clientRect.width / 2,\n    y: clientRect.top + clientRect.height / 2,\n  };\n}\n\nexport function resetTransform(nodes: ItemRef[] = []): void {\n  for (let i = 0, len = nodes.length; i < len; i++) {\n    const node = nodes[i];\n    const el = node.node;\n\n    if (!el) return;\n\n    // Clear the cached offsetTop / offsetLeft value\n    node.edgeOffset = null;\n\n    // Remove the transforms / transitions\n    setTransform(el);\n  }\n}\n\nexport function setTransform(el: HTMLElement | null, transform = '', duration = ''): void {\n  if (!el) return;\n  el.style['transform'] = transform;\n  el.style['transitionDuration'] = duration;\n}\n\nfunction withinBounds(pos: number, top: number, bottom: number) {\n  const upper = Math.max(top, bottom);\n  const lower = Math.min(top, bottom);\n  return lower <= pos && pos <= upper;\n}\n\nexport function isPointWithinRect({ x, y }: XY, { top, left, width, height }: ClientRect): boolean {\n  const withinX = withinBounds(x, left, left + width);\n  const withinY = withinBounds(y, top, top + height);\n  return withinX && withinY;\n}\n","/* eslint-disable @typescript-eslint/ban-ts-comment */\n/* eslint-disable @typescript-eslint/no-non-null-assertion */\nimport { defineComponent, PropType } from 'vue';\nimport Manager, { ItemRef, SortableNode } from './Manager';\nimport SlicksortHub, { AcceptProp, ContainerRef } from './SlicksortHub';\nimport {\n  arrayMove,\n  arrayRemove,\n  arrayInsert,\n  cloneNode,\n  closest,\n  commonOffsetParent,\n  events,\n  getEdgeOffset,\n  getElementMargin,\n  getLockPixelOffsets,\n  getPointerOffset,\n  limit,\n  resetTransform,\n  XY,\n  TopLeft,\n  WidthHeight,\n  PointEvent,\n  BottomRight,\n  isTouch,\n  setTransform,\n  hasOwnProperty,\n} from './utils';\n\ntype PointEventListener = (e: PointEvent) => unknown;\n// eslint-disable-next-line @typescript-eslint/ban-types\nconst timeout: (cb: Function, dur?: number) => number = setTimeout;\ntype Timer = number | null;\n\ninterface ComponentProps {\n  list: unknown[];\n  axis: 'x' | 'y' | 'xy' | 'yx'; // 'x', 'y', 'xy'\n  distance: number;\n  pressDelay: number;\n  pressThreshold: number;\n  useDragHandle: boolean;\n  useWindowAsScrollContainer: boolean;\n  hideSortableGhost: boolean;\n  lockToContainerEdges: boolean;\n  lockOffset: string | number | string[];\n  transitionDuration: number;\n  appendTo: string;\n  draggedSettlingDuration: number;\n  group: string;\n  accept: boolean | string[] | ((ctx: { source: ContainerRef; dest: ContainerRef; payload: unknown }) => boolean);\n  cancelKey: string;\n  block: string[];\n  lockAxis: string;\n  helperClass: string;\n  contentWindow: Window;\n  shouldCancelStart: (e: PointEvent) => boolean;\n  getHelperDimensions: (ref: ItemRef) => { width: number; height: number };\n}\n\ninterface ComponentData extends ComponentProps {\n  id: string;\n\n  // usually thi.$el\n  container: HTMLElement;\n\n  // ref to document\n  document: Document;\n\n  // Provided for sortable elements to register\n  manager: Manager;\n\n  // ref to window\n  _window: Window;\n\n  // window or container\n  // TODO make this a prop\n  scrollContainer: { scrollTop: number; scrollLeft: number };\n\n  // Injected and used for drag and drop between lists\n  hub?: SlicksortHub;\n\n  // Normalized events for mouse and touch devices\n  events: Record<string, PointEventListener>;\n\n  // MOusedown or touchstart occurred\n  _touched: boolean;\n\n  // initial point of contact\n  _pos: XY;\n\n  // distance from _pos to current pointer position\n  // Used for drag threshold, aka `distance`\n  _delta: XY;\n\n  // Data structure for `axis` prop\n  _axis: { x: boolean; y: boolean };\n\n  // timer for press threshold\n  pressTimer: Timer;\n\n  // used to wait until next tick to cancel\n  cancelTimer: Timer;\n\n  // dragout transition timer\n  dragendTimer: Timer;\n\n  // Used for repeating autoscroll\n  autoscrollInterval: Timer;\n\n  // The translation applied to the helper\n  translate: XY;\n\n  // The minmax values of translate before starting autoscroll\n  minTranslate: Partial<XY>;\n  maxTranslate: Partial<XY>;\n\n  // Is the user currently sorting\n  sorting: boolean;\n\n  // The user has initiated a cancel action\n  canceling: boolean;\n\n  // The active node that was originally clicked\n  node: SortableNode;\n\n  // The measurements of the node that have to be calculated separately\n  margin: TopLeft & BottomRight;\n  width: number;\n  height: number;\n\n  // space added around the active node\n  marginOffset: XY;\n\n  // Initial offset of the cursor\n  initialOffset: XY;\n\n  // Initial scroll position of the container and window\n  initialScroll: TopLeft;\n  initialWindowScroll: TopLeft;\n\n  // The top-left offset of the node from the offsetParent of the *container*\n  // Its important to use the container as a source for the offsetParent so all nodes have the same reference point\n  offsetEdge: TopLeft;\n\n  // client rect for the node and container\n  boundingClientRect: ClientRect;\n  containerBoundingRect: ClientRect;\n\n  // Starting index (use last index for drag in operations)\n  index: number | null;\n\n  // Target index for dropping\n  newIndex: number | null;\n\n  // The node that follows the mouse\n  helper: HTMLElement | null;\n\n  // The node that stays in the list and is hidden\n  sortableGhost: HTMLElement | null;\n\n  // The element that we listen to for events\n  listenerNode: GlobalEventHandlers;\n}\n\n// Export Sortable Container Component Mixin\nexport const ContainerMixin = defineComponent({\n  inject: { \n    SlicksortHub: {\n      from: 'SlicksortHub',\n      default: null,\n    },\n  },\n\n  provide() {\n    return {\n      manager: this.manager,\n    };\n  },\n\n  props: {\n    list: { type: Array as PropType<unknown[]>, required: true },\n    axis: { type: String, default: 'y' }, // 'x', 'y', 'xy'\n    distance: { type: Number, default: 0 },\n    pressDelay: { type: Number, default: 0 },\n    pressThreshold: { type: Number, default: 5 },\n    useDragHandle: { type: Boolean, default: false },\n    useWindowAsScrollContainer: { type: Boolean, default: false },\n    hideSortableGhost: { type: Boolean, default: true },\n    lockToContainerEdges: { type: Boolean, default: false },\n    lockOffset: { type: [String, Number, Array] as PropType<string | number | number[]>, default: '50%' },\n    transitionDuration: { type: Number, default: 300 },\n    appendTo: { type: String, default: 'body' },\n    draggedSettlingDuration: { type: Number, default: null },\n    group: { type: String, default: '' },\n    accept: { type: [Boolean, Array, Function] as PropType<AcceptProp>, default: null },\n    cancelKey: { type: String, default: 'Escape' },\n    block: { type: Array as PropType<string[]>, default: () => [] },\n    lockAxis: { type: String, default: '' },\n    helperClass: { type: String, default: '' },\n    contentWindow: { type: Object as PropType<Window>, default: null },\n    shouldCancelStart: {\n      type: Function as PropType<PointEventListener>,\n      default: (e: PointEvent) => {\n        // Cancel sorting if the event target is an `input`, `textarea`, `select` or `option`\n        const disabledElements = ['input', 'textarea', 'select', 'option', 'button'];\n        return disabledElements.indexOf((e.target as HTMLElement).tagName.toLowerCase()) !== -1;\n      },\n    },\n    getHelperDimensions: {\n      type: Function as PropType<(arg: ItemRef) => WidthHeight>,\n      default: ({ node }: ItemRef) => ({\n        width: node.offsetWidth,\n        height: node.offsetHeight,\n      }),\n    },\n  },\n\n  emits: ['sort-start', 'sort-move', 'sort-end', 'sort-cancel', 'sort-insert', 'sort-remove', 'update:list'],\n\n  data() {\n    let useHub = false;\n    if (this.group) {\n      // If the group option is set, it is assumed the user intends\n      // to drag between containers and the required plugin has been installed\n      if (this.SlicksortHub) {\n        useHub = true;\n      } else if (process.env.NODE_ENV !== 'production') {\n        throw new Error('Slicksort plugin required to use \"group\" prop');\n      }\n    }\n\n    return ({\n      sorting: false,\n      hub: useHub ? this.SlicksortHub : null,\n      manager: new Manager(),\n    } as unknown) as ComponentData;\n  },\n\n  mounted() {\n    if (this.hub) {\n      this.id = this.hub.getId();\n    }\n    this.container = this.$el;\n    this.document = this.container.ownerDocument || document;\n    this._window = this.contentWindow || window;\n    this.scrollContainer = this.useWindowAsScrollContainer ? { scrollLeft: 0, scrollTop: 0 } : this.container;\n    this.events = {\n      start: this.handleStart,\n      move: this.handleMove,\n      end: this.handleEnd,\n    };\n\n    for (const key in this.events) {\n      if (hasOwnProperty(this.events, key)) {\n        // @ts-ignore\n        events[key].forEach((eventName) => this.container.addEventListener(eventName, this.events[key]));\n      }\n    }\n\n    if (this.hub) {\n      this.hub.addContainer(this as ContainerRef);\n    }\n  },\n\n  beforeUnmount() {\n    for (const key in this.events) {\n      if (hasOwnProperty(this.events, key)) {\n        // @ts-ignore\n        events[key].forEach((eventName) => this.container.removeEventListener(eventName, this.events[key]));\n      }\n    }\n\n    if (this.hub) {\n      this.hub.removeContainer(this as ContainerRef);\n    }\n\n    if (this.dragendTimer) clearTimeout(this.dragendTimer);\n    if (this.cancelTimer) clearTimeout(this.cancelTimer);\n    if (this.pressTimer) clearTimeout(this.pressTimer);\n    if (this.autoscrollInterval) clearInterval(this.autoscrollInterval);\n  },\n\n  methods: {\n    handleStart(e: PointEvent) {\n      const { distance, shouldCancelStart } = this.$props;\n\n      if ((!isTouch(e) && e.button === 2) || shouldCancelStart(e)) {\n        return false;\n      }\n\n      this._touched = true;\n      this._pos = getPointerOffset(e);\n      const target = e.target as HTMLElement;\n\n      const node = closest(target, (el) => (el as SortableNode).sortableInfo != null) as SortableNode;\n\n      if (node && node.sortableInfo && this.nodeIsChild(node) && !this.sorting) {\n        const { useDragHandle } = this.$props;\n        const { index } = node.sortableInfo;\n\n        if (useDragHandle && !closest(target, (el) => (el as SortableNode).sortableHandle != null)) return;\n\n        this.manager.active = { index };\n\n        /*\n         * Fixes a bug in Firefox where the :active state of anchor tags\n         * prevent subsequent 'mousemove' events from being fired\n         * (see https://github.com/clauderic/react-sortable-hoc/issues/118)\n         */\n        if (target.tagName.toLowerCase() === 'a') {\n          e.preventDefault();\n        }\n\n        if (!distance) {\n          if (this.pressDelay === 0) {\n            this.handlePress(e);\n          } else {\n            this.pressTimer = timeout(() => this.handlePress(e), this.pressDelay) as Timer;\n          }\n        }\n      }\n    },\n\n    nodeIsChild(node: SortableNode) {\n      return node.sortableInfo.manager === this.manager;\n    },\n\n    handleMove(e: PointEvent) {\n      const { distance, pressThreshold } = this.$props;\n\n      if (!this.sorting && this._touched) {\n        const offset = getPointerOffset(e);\n        this._delta = {\n          x: this._pos.x - offset.x,\n          y: this._pos.y - offset.y,\n        };\n        const delta = Math.abs(this._delta.x) + Math.abs(this._delta.y);\n\n        if (!distance && (!pressThreshold || (pressThreshold && delta >= pressThreshold))) {\n          if (this.cancelTimer) clearTimeout(this.cancelTimer);\n          this.cancelTimer = timeout(this.cancel, 0);\n        } else if (distance && delta >= distance && this.manager.isActive()) {\n          this.handlePress(e);\n        }\n      }\n    },\n\n    handleEnd() {\n      if (!this._touched) return;\n\n      const { distance } = this.$props;\n\n      this._touched = false;\n\n      if (!distance) {\n        this.cancel();\n      }\n    },\n\n    cancel() {\n      if (!this.sorting) {\n        if (this.pressTimer) clearTimeout(this.pressTimer);\n        this.manager.active = null;\n        if (this.hub) this.hub.cancel();\n      }\n    },\n\n    handleSortCancel(e: KeyboardEvent | TouchEvent) {\n      if (isTouch(e) || e.key === this.cancelKey) {\n        this.newIndex = this.index;\n        this.canceling = true;\n        this.translate = { x: 0, y: 0 };\n        this.animateNodes();\n        this.handleSortEnd(e);\n      }\n    },\n\n    handlePress(e: PointEvent) {\n      e.stopPropagation();\n      const active = this.manager.getActive();\n\n      if (active) {\n        const { getHelperDimensions, helperClass, hideSortableGhost, appendTo } = this.$props;\n        const { node } = active;\n        const { index } = node.sortableInfo;\n        const margin = getElementMargin(node);\n\n        const containerBoundingRect = this.container.getBoundingClientRect();\n        const dimensions = getHelperDimensions({ index, node });\n\n        this.node = node;\n        this.margin = margin;\n        this.width = dimensions.width;\n        this.height = dimensions.height;\n        this.marginOffset = {\n          x: this.margin.left + this.margin.right,\n          y: Math.max(this.margin.top, this.margin.bottom),\n        };\n        this.boundingClientRect = node.getBoundingClientRect();\n        this.containerBoundingRect = containerBoundingRect;\n        this.index = index;\n        this.newIndex = index;\n\n        const clonedNode = cloneNode(node);\n\n        this.helper = this.document.querySelector(appendTo)!.appendChild(clonedNode);\n\n        this.helper.style.position = 'fixed';\n        this.helper.style.top = `${this.boundingClientRect.top - margin.top}px`;\n        this.helper.style.left = `${this.boundingClientRect.left - margin.left}px`;\n        this.helper.style.width = `${this.width}px`;\n        this.helper.style.height = `${this.height}px`;\n        this.helper.style.boxSizing = 'border-box';\n        this.helper.style.pointerEvents = 'none';\n\n        if (hideSortableGhost) {\n          this.sortableGhost = node;\n          node.style.visibility = 'hidden';\n          node.style.opacity = '0';\n        }\n\n        if (this.hub) {\n          this.hub.sortStart(this as ContainerRef);\n          this.hub.helper = this.helper;\n          this.hub.ghost = this.sortableGhost;\n        }\n\n        this.intializeOffsets(e, this.boundingClientRect);\n        this.offsetEdge = getEdgeOffset(node, this.container);\n\n        if (helperClass) {\n          this.helper.classList.add(...helperClass.split(' '));\n        }\n\n        this.listenerNode = isTouch(e) ? node : this._window;\n        // @ts-ignore\n        events.move.forEach((eventName) => this.listenerNode.addEventListener(eventName, this.handleSortMove));\n        // @ts-ignore\n        events.end.forEach((eventName) => this.listenerNode.addEventListener(eventName, this.handleSortEnd));\n        // @ts-ignore\n        events.cancel.forEach((eventName) => this.listenerNode.addEventListener(eventName, this.handleSortCancel));\n\n        this.sorting = true;\n\n        this.$emit('sort-start', { event: e, node, index });\n      }\n    },\n\n    handleSortMove(e: PointEvent) {\n      e.preventDefault(); // Prevent scrolling on mobile\n\n      this.updatePosition(e);\n\n      if (this.hub) {\n        const payload = this.list[this.index!];\n        this.hub.handleSortMove(e, payload);\n      }\n\n      if (!this.hub || this.hub.isDest(this as ContainerRef)) {\n        this.animateNodes();\n        this.autoscroll();\n      }\n\n      this.$emit('sort-move', { event: e });\n    },\n\n    handleDropOut() {\n      const removed = this.list[this.index!];\n      const newValue = arrayRemove(this.list, this.index!);\n      this.$emit('sort-remove', {\n        oldIndex: this.index,\n      });\n      this.$emit('update:list', newValue);\n      return removed;\n    },\n\n    handleDropIn(payload: unknown) {\n      const newValue = arrayInsert(this.list, this.newIndex!, payload);\n      this.$emit('sort-insert', {\n        newIndex: this.newIndex,\n        value: payload,\n      });\n      this.$emit('update:list', newValue);\n      this.handleDragEnd();\n    },\n\n    handleDragOut() {\n      if (this.autoscrollInterval) {\n        clearInterval(this.autoscrollInterval);\n        this.autoscrollInterval = null;\n      }\n      if (this.hub!.isSource(this as ContainerRef)) {\n        // Trick to animate all nodes up\n        this.translate = {\n          x: 10000,\n          y: 10000,\n        };\n        this.animateNodes();\n      } else {\n        this.manager.getRefs().forEach((ref) => {\n          ref.node.style['transform'] = '';\n        });\n        this.dragendTimer = timeout(this.handleDragEnd, this.transitionDuration || 0);\n      }\n    },\n\n    handleDragEnd() {\n      if (this.autoscrollInterval) {\n        clearInterval(this.autoscrollInterval);\n        this.autoscrollInterval = null;\n      }\n\n      resetTransform(this.manager.getRefs());\n      if (this.sortableGhost) {\n        this.sortableGhost.remove();\n        this.sortableGhost = null;\n      }\n\n      if (this.dragendTimer) {\n        clearTimeout(this.dragendTimer);\n        this.dragendTimer = null;\n      }\n      this.manager.active = null;\n      this._touched = false;\n      this.sorting = false;\n    },\n\n    intializeOffsets(e: PointEvent, clientRect: ClientRect) {\n      const { useWindowAsScrollContainer, containerBoundingRect, _window } = this;\n\n      this.marginOffset = {\n        x: this.margin.left + this.margin.right,\n        y: Math.max(this.margin.top, this.margin.bottom),\n      };\n\n      this._axis = {\n        x: this.axis.indexOf('x') >= 0,\n        y: this.axis.indexOf('y') >= 0,\n      };\n\n      this.initialOffset = getPointerOffset(e);\n\n      // initialScroll;\n      this.initialScroll = {\n        top: this.scrollContainer.scrollTop,\n        left: this.scrollContainer.scrollLeft,\n      };\n\n      // initialWindowScroll;\n      this.initialWindowScroll = {\n        top: window.pageYOffset,\n        left: window.pageXOffset,\n      };\n\n      this.translate = { x: 0, y: 0 };\n      this.minTranslate = {};\n      this.maxTranslate = {};\n\n      if (this._axis.x) {\n        this.minTranslate.x =\n          (useWindowAsScrollContainer ? 0 : containerBoundingRect.left) - clientRect.left - this.width / 2;\n        this.maxTranslate.x =\n          (useWindowAsScrollContainer ? _window.innerWidth : containerBoundingRect.left + containerBoundingRect.width) -\n          clientRect.left -\n          this.width / 2;\n      }\n      if (this._axis.y) {\n        this.minTranslate.y =\n          (useWindowAsScrollContainer ? 0 : containerBoundingRect.top) - clientRect.top - this.height / 2;\n        this.maxTranslate.y =\n          (useWindowAsScrollContainer\n            ? _window.innerHeight\n            : containerBoundingRect.top + containerBoundingRect.height) -\n          clientRect.top -\n          this.height / 2;\n      }\n    },\n\n    handleDragIn(e: PointEvent, sortableGhost: SortableNode, helper: SortableNode) {\n      if (this.hub!.isSource(this as ContainerRef)) {\n        return;\n      }\n\n      if (this.dragendTimer) {\n        this.handleDragEnd();\n        clearTimeout(this.dragendTimer);\n        this.dragendTimer = null;\n      }\n\n      const nodes = this.manager.getRefs();\n      this.index = nodes.length;\n      this.manager.active = { index: this.index };\n\n      const containerBoundingRect = this.container.getBoundingClientRect();\n      const helperBoundingRect = helper.getBoundingClientRect();\n      this.containerBoundingRect = containerBoundingRect;\n\n      this.sortableGhost = cloneNode(sortableGhost);\n      this.container.appendChild(this.sortableGhost);\n      const ghostRect = this.sortableGhost.getBoundingClientRect();\n      this.boundingClientRect = ghostRect;\n      this.margin = getElementMargin(this.sortableGhost);\n      this.width = ghostRect.width;\n      this.height = ghostRect.height;\n\n      // XY coords of the inserted node, relative to the top-left corner of the container\n      this.offsetEdge = getEdgeOffset(this.sortableGhost, this.container);\n\n      this.intializeOffsets(e, ghostRect);\n\n      // Move the initialOffset back to the insertion point of the\n      // sortableGhost (end of the list), as if we had started the drag there.\n      this.initialOffset.x += ghostRect.x - helperBoundingRect.x;\n      this.initialOffset.y += ghostRect.y - helperBoundingRect.y;\n\n      // Turn on dragging\n      this.sorting = true;\n    },\n\n    handleSortEnd(e: PointEvent | KeyboardEvent) {\n      // Remove the event listeners if the node is still in the DOM\n      if (this.listenerNode) {\n        events.move.forEach((eventName) =>\n          // @ts-ignore\n          this.listenerNode.removeEventListener(eventName, this.handleSortMove),\n        );\n        events.end.forEach((eventName) =>\n          // @ts-ignore\n          this.listenerNode.removeEventListener(eventName, this.handleSortEnd),\n        );\n        events.cancel.forEach((eventName) =>\n          // @ts-ignore\n          this.listenerNode.removeEventListener(eventName, this.handleSortCancel),\n        );\n      }\n\n      const nodes = this.manager.getRefs();\n\n      // Remove the helper class(es) early to give it a chance to transition back\n      if (this.helper && this.helperClass) {\n        this.helper.classList.remove(...this.helperClass.split(' '));\n      }\n\n      // Stop autoscroll\n      if (this.autoscrollInterval) clearInterval(this.autoscrollInterval);\n      this.autoscrollInterval = null;\n\n      const onEnd = () => {\n        // Remove the helper from the DOM\n        if (this.helper) {\n          this.helper.remove();\n          this.helper = null;\n        }\n\n        if (this.hideSortableGhost && this.sortableGhost) {\n          this.sortableGhost.style.visibility = '';\n          this.sortableGhost.style.opacity = '';\n        }\n\n        resetTransform(nodes);\n\n        // Update state\n        if (this.hub && !this.hub.isDest(this as ContainerRef)) {\n          this.canceling ? this.hub.cancel() : this.hub.handleSortEnd();\n        } else if (this.canceling) {\n          this.$emit('sort-cancel', { event: e });\n        } else {\n          this.$emit('sort-end', {\n            event: e,\n            oldIndex: this.index,\n            newIndex: this.newIndex,\n          });\n          this.$emit('update:list', arrayMove(this.list, this.index!, this.newIndex!));\n        }\n\n        this.manager.active = null;\n        this._touched = false;\n        this.canceling = false;\n        this.sorting = false;\n      };\n\n      if (this.transitionDuration || this.draggedSettlingDuration) {\n        this.transitionHelperIntoPlace(nodes, onEnd);\n      } else {\n        onEnd();\n      }\n    },\n\n    transitionHelperIntoPlace(nodes: ItemRef[], cb: () => void) {\n      if (this.draggedSettlingDuration === 0 || nodes.length === 0 || !this.helper) {\n        return Promise.resolve();\n      }\n\n      const indexNode = nodes[this.index!].node;\n      let targetX = 0;\n      let targetY = 0;\n\n      const scrollDifference = {\n        top: window.pageYOffset - this.initialWindowScroll.top,\n        left: window.pageXOffset - this.initialWindowScroll.left,\n      };\n\n      if (this.hub && !this.hub.isDest(this as ContainerRef) && !this.canceling) {\n        const dest = this.hub.getDest();\n        if (!dest) return;\n        const destIndex = dest.newIndex;\n        const destRefs = dest.manager.getOrderedRefs();\n        const destNode = destIndex < destRefs.length ? destRefs[destIndex].node : dest.sortableGhost!;\n        const ancestor = commonOffsetParent(indexNode, destNode)!;\n\n        const sourceOffset = getEdgeOffset(indexNode, ancestor);\n        const targetOffset = getEdgeOffset(destNode, ancestor);\n\n        targetX = targetOffset.left - sourceOffset.left - scrollDifference.left;\n        targetY = targetOffset.top - sourceOffset.top - scrollDifference.top;\n      } else {\n        const newIndexNode = nodes[this.newIndex!].node;\n        const deltaScroll = {\n          left: this.scrollContainer.scrollLeft - this.initialScroll.left + scrollDifference.left,\n          top: this.scrollContainer.scrollTop - this.initialScroll.top + scrollDifference.top,\n        };\n        targetX = -deltaScroll.left;\n        if (this.translate && this.translate.x > 0) {\n          // Diff against right edge when moving to the right\n          targetX +=\n            newIndexNode.offsetLeft + newIndexNode.offsetWidth - (indexNode.offsetLeft + indexNode.offsetWidth);\n        } else {\n          targetX += newIndexNode.offsetLeft - indexNode.offsetLeft;\n        }\n\n        targetY = -deltaScroll.top;\n        if (this.translate && this.translate.y > 0) {\n          // Diff against the bottom edge when moving down\n          targetY +=\n            newIndexNode.offsetTop + newIndexNode.offsetHeight - (indexNode.offsetTop + indexNode.offsetHeight);\n        } else {\n          targetY += newIndexNode.offsetTop - indexNode.offsetTop;\n        }\n      }\n\n      const duration = this.draggedSettlingDuration !== null ? this.draggedSettlingDuration : this.transitionDuration;\n\n      setTransform(this.helper, `translate3d(${targetX}px,${targetY}px, 0)`, `${duration}ms`);\n\n      // Register an event handler to clean up styles when the transition\n      // finishes.\n      const cleanup = (event: TransitionEvent) => {\n        if (!event || event.propertyName === 'transform') {\n          clearTimeout(cleanupTimer);\n          setTransform(this.helper);\n          cb();\n        }\n      };\n      // Force cleanup in case 'transitionend' never fires\n      const cleanupTimer = setTimeout(cleanup, duration + 10);\n      this.helper.addEventListener('transitionend', cleanup);\n    },\n\n    updatePosition(e: PointEvent) {\n      const { lockAxis, lockToContainerEdges } = this.$props;\n\n      const offset = getPointerOffset(e);\n      const translate = {\n        x: offset.x - this.initialOffset.x,\n        y: offset.y - this.initialOffset.y,\n      };\n      // Adjust for window scroll\n      translate.y -= window.pageYOffset - this.initialWindowScroll.top;\n      translate.x -= window.pageXOffset - this.initialWindowScroll.left;\n\n      this.translate = translate;\n\n      if (lockToContainerEdges) {\n        const [minLockOffset, maxLockOffset] = getLockPixelOffsets(this.lockOffset, this.height, this.width);\n        const minOffset = {\n          x: this.width / 2 - minLockOffset.x,\n          y: this.height / 2 - minLockOffset.y,\n        };\n        const maxOffset = {\n          x: this.width / 2 - maxLockOffset.x,\n          y: this.height / 2 - maxLockOffset.y,\n        };\n\n        if (this.minTranslate.x && this.maxTranslate.x)\n          translate.x = limit(this.minTranslate.x + minOffset.x, this.maxTranslate.x - maxOffset.x, translate.x);\n        if (this.minTranslate.y && this.maxTranslate.y)\n          translate.y = limit(this.minTranslate.y + minOffset.y, this.maxTranslate.y - maxOffset.y, translate.y);\n      }\n\n      if (lockAxis === 'x') {\n        translate.y = 0;\n      } else if (lockAxis === 'y') {\n        translate.x = 0;\n      }\n\n      if (this.helper) {\n        this.helper.style['transform'] = `translate3d(${translate.x}px,${translate.y}px, 0)`;\n      }\n    },\n\n    animateNodes() {\n      const { transitionDuration, hideSortableGhost } = this.$props;\n      const nodes = this.manager.getOrderedRefs();\n      const deltaScroll = {\n        left: this.scrollContainer.scrollLeft - this.initialScroll.left,\n        top: this.scrollContainer.scrollTop - this.initialScroll.top,\n      };\n      const sortingOffset = {\n        left: this.offsetEdge.left + this.translate.x + deltaScroll.left,\n        top: this.offsetEdge.top + this.translate.y + deltaScroll.top,\n      };\n      const scrollDifference = {\n        top: window.pageYOffset - this.initialWindowScroll.top,\n        left: window.pageXOffset - this.initialWindowScroll.left,\n      };\n      this.newIndex = null;\n\n      for (let i = 0, len = nodes.length; i < len; i++) {\n        const { node } = nodes[i];\n        const index = node.sortableInfo.index;\n        const width = node.offsetWidth;\n        const height = node.offsetHeight;\n        const offset = {\n          width: this.width > width ? width / 2 : this.width / 2,\n          height: this.height > height ? height / 2 : this.height / 2,\n        };\n\n        const translate = {\n          x: 0,\n          y: 0,\n        };\n        let { edgeOffset } = nodes[i];\n\n        // If we haven't cached the node's offsetTop / offsetLeft value\n        if (!edgeOffset) {\n          nodes[i].edgeOffset = edgeOffset = getEdgeOffset(node, this.container);\n        }\n\n        // Get a reference to the next and previous node\n        const nextNode = i < nodes.length - 1 && nodes[i + 1];\n        const prevNode = i > 0 && nodes[i - 1];\n\n        // Also cache the next node's edge offset if needed.\n        // We need this for calculating the animation in a grid setup\n        if (nextNode && !nextNode.edgeOffset) {\n          nextNode.edgeOffset = getEdgeOffset(nextNode.node, this.container);\n        }\n\n        // If the node is the one we're currently animating, skip it\n        if (index === this.index) {\n          /*\n           * With windowing libraries such as `react-virtualized`, the sortableGhost\n           * node may change while scrolling down and then back up (or vice-versa),\n           * so we need to update the reference to the new node just to be safe.\n           */\n          if (hideSortableGhost) {\n            this.sortableGhost = node;\n            node.style.visibility = 'hidden';\n            node.style.opacity = '0';\n          }\n\n          continue;\n        }\n\n        if (transitionDuration) {\n          node.style['transitionDuration'] = `${transitionDuration}ms`;\n        }\n\n        if (this._axis.x) {\n          if (this._axis.y) {\n            // Calculations for a grid setup\n            if (\n              index < this.index! &&\n              ((sortingOffset.left + scrollDifference.left - offset.width <= edgeOffset.left &&\n                sortingOffset.top + scrollDifference.top <= edgeOffset.top + offset.height) ||\n                sortingOffset.top + scrollDifference.top + offset.height <= edgeOffset.top)\n            ) {\n              // If the current node is to the left on the same row, or above the node that's being dragged\n              // then move it to the right\n              translate.x = this.width + this.marginOffset.x;\n              if (edgeOffset.left + translate.x > this.containerBoundingRect.width - offset.width && nextNode) {\n                // If it moves passed the right bounds, then animate it to the first position of the next row.\n                // We just use the offset of the next node to calculate where to move, because that node's original position\n                // is exactly where we want to go\n                translate.x = nextNode.edgeOffset!.left - edgeOffset.left;\n                translate.y = nextNode.edgeOffset!.top - edgeOffset.top;\n              }\n              if (this.newIndex === null) {\n                this.newIndex = index;\n              }\n            } else if (\n              index > this.index! &&\n              ((sortingOffset.left + scrollDifference.left + offset.width >= edgeOffset.left &&\n                sortingOffset.top + scrollDifference.top + offset.height >= edgeOffset.top) ||\n                sortingOffset.top + scrollDifference.top + offset.height >= edgeOffset.top + height)\n            ) {\n              // If the current node is to the right on the same row, or below the node that's being dragged\n              // then move it to the left\n              translate.x = -(this.width + this.marginOffset.x);\n              if (edgeOffset.left + translate.x < this.containerBoundingRect.left + offset.width && prevNode) {\n                // If it moves passed the left bounds, then animate it to the last position of the previous row.\n                // We just use the offset of the previous node to calculate where to move, because that node's original position\n                // is exactly where we want to go\n                translate.x = prevNode.edgeOffset!.left - edgeOffset.left;\n                translate.y = prevNode.edgeOffset!.top - edgeOffset.top;\n              }\n              this.newIndex = index;\n            }\n          } else {\n            if (index > this.index! && sortingOffset.left + scrollDifference.left + offset.width >= edgeOffset.left) {\n              translate.x = -(this.width + this.marginOffset.x);\n              this.newIndex = index;\n            } else if (\n              index < this.index! &&\n              sortingOffset.left + scrollDifference.left <= edgeOffset.left + offset.width\n            ) {\n              translate.x = this.width + this.marginOffset.x;\n              if (this.newIndex == null) {\n                this.newIndex = index;\n              }\n            }\n          }\n        } else if (this._axis.y) {\n          if (index > this.index! && sortingOffset.top + scrollDifference.top + offset.height >= edgeOffset.top) {\n            translate.y = -(this.height + this.marginOffset.y);\n            this.newIndex = index;\n          } else if (\n            index < this.index! &&\n            sortingOffset.top + scrollDifference.top <= edgeOffset.top + offset.height\n          ) {\n            translate.y = this.height + this.marginOffset.y;\n            if (this.newIndex == null) {\n              this.newIndex = index;\n            }\n          }\n        }\n        node.style['transform'] = `translate3d(${translate.x}px,${translate.y}px,0)`;\n      }\n\n      if (this.newIndex == null) {\n        this.newIndex = this.index;\n      }\n    },\n\n    autoscroll() {\n      const translate = this.translate;\n      const direction = {\n        x: 0,\n        y: 0,\n      };\n      const speed = {\n        x: 1,\n        y: 1,\n      };\n      const acceleration = {\n        x: 10,\n        y: 10,\n      };\n\n      if (translate.y >= this.maxTranslate.y! - this.height / 2) {\n        direction.y = 1; // Scroll Down\n        speed.y = acceleration.y * Math.abs((this.maxTranslate.y! - this.height / 2 - translate.y) / this.height);\n      } else if (translate.x >= this.maxTranslate.x! - this.width / 2) {\n        direction.x = 1; // Scroll Right\n        speed.x = acceleration.x * Math.abs((this.maxTranslate.x! - this.width / 2 - translate.x) / this.width);\n      } else if (translate.y <= this.minTranslate.y! + this.height / 2) {\n        direction.y = -1; // Scroll Up\n        speed.y = acceleration.y * Math.abs((translate.y - this.height / 2 - this.minTranslate.y!) / this.height);\n      } else if (translate.x <= this.minTranslate.x! + this.width / 2) {\n        direction.x = -1; // Scroll Left\n        speed.x = acceleration.x * Math.abs((translate.x - this.width / 2 - this.minTranslate.x!) / this.width);\n      }\n\n      if (this.autoscrollInterval) {\n        clearInterval(this.autoscrollInterval);\n        this.autoscrollInterval = null;\n      }\n\n      if (direction.x !== 0 || direction.y !== 0) {\n        this.autoscrollInterval = window.setInterval(() => {\n          const offset = {\n            left: 1 * speed.x * direction.x,\n            top: 1 * speed.y * direction.y,\n          };\n\n          if (this.useWindowAsScrollContainer) {\n            this._window.scrollBy(offset.left, offset.top);\n          } else {\n            this.scrollContainer.scrollTop += offset.top;\n            this.scrollContainer.scrollLeft += offset.left;\n          }\n\n          this.translate.x += offset.left;\n          this.translate.y += offset.top;\n          this.animateNodes();\n        }, 5);\n      }\n    },\n  },\n});\n","import { Directive } from 'vue';\n\n// Export Sortable Element Handle Directive\nexport const HandleDirective: Directive = {\n  beforeMount(el) {\n    el.sortableHandle = true;\n  },\n};\n","import { h, defineComponent } from 'vue';\nimport { ElementMixin } from '../ElementMixin';\n\nexport const SlickItem = defineComponent({\n  name: 'SlickItem',\n  mixins: [ElementMixin],\n  props: {\n    tag: {\n      type: String,\n      default: 'div',\n    },\n  },\n  render() {\n    return h(this.tag, this.$slots.default?.());\n  },\n});\n","import { h, defineComponent, PropType } from 'vue';\nimport { ContainerMixin } from '../ContainerMixin';\nimport { hasOwnProperty } from '../utils';\nimport { SlickItem } from './SlickItem';\n\nexport const SlickList = defineComponent({\n  name: 'SlickList',\n  mixins: [ContainerMixin],\n  props: {\n    tag: {\n      type: String,\n      default: 'div',\n    },\n    itemKey: {\n      type: [String, Function] as PropType<((item: unknown) => string) | string>,\n      default: 'id',\n    },\n  },\n  render() {\n    if (this.$slots.item) {\n      return h(\n        this.tag,\n        this.list.map((item, index) => {\n          let key: string;\n          if (item == null) {\n            return;\n          } else if (typeof this.itemKey === 'function') {\n            key = this.itemKey(item);\n          } else if (\n            typeof item === 'object' &&\n            hasOwnProperty(item, this.itemKey) &&\n            typeof item[this.itemKey] == 'string'\n          ) {\n            key = item[this.itemKey] as string;\n          } else if (typeof item === 'string') {\n            key = item;\n          } else {\n            throw new Error('Cannot find key for item, use the item-key prop and pass a function or string');\n          }\n          return h(\n            SlickItem,\n            {\n              key,\n              index,\n            },\n            {\n              default: () => this.$slots.item?.({ item, index }),\n            },\n          );\n        }),\n      );\n    }\n    return h(this.tag, this.$slots.default?.());\n  },\n});\n","import { h, defineComponent } from 'vue';\n\nexport const DragHandle = defineComponent({\n  props: {\n    tag: {\n      type: String,\n      default: 'span',\n    },\n  },\n  mounted() {\n    this.$el.sortableHandle = true;\n  },\n  render() {\n    return h(this.tag, this.$slots.default?.());\n  },\n});\n","import Manager from './Manager';\nimport { getRectCenter, getDistance, getPointerOffset, isPointWithinRect, PointEvent } from './utils';\n\nlet containerIDCounter = 1;\n\nexport interface ContainerRef {\n  id: string;\n  group: string;\n  accept: AcceptProp | null;\n  block: string[];\n  container: HTMLElement;\n  newIndex: number;\n  manager: Manager;\n  sortableGhost: HTMLElement | null;\n\n  handleDragIn(e: PointEvent, ghost: HTMLElement | null, helper: HTMLElement | null): void;\n  handleDragOut(): void;\n  handleDragEnd(): void;\n  handleSortEnd(e: PointEvent): void;\n  handleDropIn(payload: unknown): void;\n  handleDropOut(): unknown;\n\n  updatePosition(e: PointEvent): void;\n  animateNodes(): void;\n  autoscroll(): void;\n}\n\ntype AcceptPropArgs = { source: ContainerRef; dest: ContainerRef; payload: unknown };\nexport type AcceptProp = boolean | string[] | ((args: AcceptPropArgs) => boolean);\n\n/**\n * Always allow when dest === source\n * Defer to 'dest.accept()' if it is a function\n * Allow any group in the accept lists\n * Deny any group in the block list\n * Allow the same group by default, this can be overridden with the block prop\n */\nfunction canAcceptElement(dest: ContainerRef, source: ContainerRef, payload: unknown): boolean {\n  if (source.id === dest.id) return true;\n  if (dest.block && dest.block.includes(source.group)) return false;\n  if (typeof dest.accept === 'function') {\n    return dest.accept({ dest, source, payload });\n  }\n  if (typeof dest.accept === 'boolean') {\n    return dest.accept;\n  }\n  if (dest.accept && dest.accept.includes(source.group)) return true;\n  if (dest.group === source.group) return true;\n  return false;\n}\n\nfunction findClosestDest(\n  { x, y }: { x: number; y: number },\n  refs: ContainerRef[],\n  currentDest: ContainerRef,\n): ContainerRef | null {\n  // Quickly check if we are within the bounds of the current destination\n  if (isPointWithinRect({ x, y }, currentDest.container.getBoundingClientRect())) {\n    return currentDest;\n  }\n\n  let closest = null;\n  let minDistance = Infinity;\n  for (let i = 0; i < refs.length; i++) {\n    const ref = refs[i];\n    const rect = ref.container.getBoundingClientRect();\n    const isWithin = isPointWithinRect({ x, y }, rect);\n\n    if (isWithin) {\n      // If we are within another destination, stop here\n      return ref;\n    }\n\n    const center = getRectCenter(rect);\n    const distance = getDistance(x, y, center.x, center.y);\n    if (distance < minDistance) {\n      closest = ref;\n      minDistance = distance;\n    }\n  }\n\n  // Try to guess the closest destination\n  return closest;\n}\n\nexport default class SlicksortHub {\n  public helper: HTMLElement | null = null;\n  public ghost: HTMLElement | null = null;\n\n  private refs: ContainerRef[] = [];\n  private source: ContainerRef | null = null;\n  private dest: ContainerRef | null = null;\n\n  getId(): string {\n    return '' + containerIDCounter++;\n  }\n\n  isSource({ id }: ContainerRef): boolean {\n    return this.source?.id === id;\n  }\n\n  getSource(): ContainerRef | null {\n    return this.source;\n  }\n\n  isDest({ id }: ContainerRef): boolean {\n    return this.dest?.id === id;\n  }\n\n  getDest(): ContainerRef | null {\n    return this.dest;\n  }\n\n  addContainer(ref: ContainerRef): void {\n    this.refs.push(ref);\n  }\n\n  removeContainer(ref: ContainerRef): void {\n    this.refs = this.refs.filter((c) => c.id !== ref.id);\n  }\n\n  sortStart(ref: ContainerRef): void {\n    this.source = ref;\n    this.dest = ref;\n  }\n\n  handleSortMove(e: PointEvent, payload: unknown): void {\n    const dest = this.dest;\n    const source = this.source;\n\n    if (!dest || !source) return;\n\n    const refs = this.refs;\n    const pointer = getPointerOffset(e, 'client');\n    const newDest = findClosestDest(pointer, refs, dest) || dest;\n\n    if (dest.id !== newDest.id && canAcceptElement(newDest, source, payload)) {\n      this.dest = newDest;\n      dest.handleDragOut();\n      newDest.handleDragIn(e, this.ghost, this.helper);\n    }\n    if (dest.id !== this.source?.id) {\n      this.dest?.updatePosition(e);\n      this.dest?.animateNodes();\n      this.dest?.autoscroll();\n    }\n  }\n\n  handleSortEnd(): void {\n    if (this.source?.id === this.dest?.id) return;\n    const payload = this.source?.handleDropOut();\n    this.dest?.handleDropIn(payload);\n    this.reset();\n  }\n\n  reset(): void {\n    this.source = null;\n    this.dest = null;\n    this.helper = null;\n    this.ghost = null;\n  }\n\n  cancel(): void {\n    this.dest?.handleDragEnd();\n    this.reset();\n  }\n}\n","import SlicksortHub from './SlicksortHub';\nimport { HandleDirective } from './HandleDirective';\nimport { Plugin } from 'vue';\n\nconst plugin: Plugin = {\n  install(app) {\n    app.directive('drag-handle', HandleDirective);\n    app.provide('SlicksortHub', new SlicksortHub());\n  },\n};\n\nexport default plugin;\n"],"names":["defineComponent","h"],"mappings":"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"}