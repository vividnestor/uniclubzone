{
  "version": 3,
  "sources": ["../../vue-slicksort/dist/vue-slicksort.esm.js"],
  "sourcesContent": ["import { defineComponent, h } from 'vue';\n\n// Export Sortable Element Component Mixin\nconst ElementMixin = defineComponent({\n    inject: ['manager'],\n    props: {\n        index: {\n            type: Number,\n            required: true,\n        },\n        disabled: {\n            type: Boolean,\n            default: false,\n        },\n    },\n    data() {\n        return {};\n    },\n    watch: {\n        index(newIndex) {\n            if (this.$el && this.$el.sortableInfo) {\n                this.$el.sortableInfo.index = newIndex;\n            }\n        },\n        disabled(isDisabled) {\n            if (isDisabled) {\n                this.removeDraggable();\n            }\n            else {\n                this.setDraggable(this.index);\n            }\n        },\n    },\n    mounted() {\n        const { disabled, index } = this.$props;\n        if (!disabled) {\n            this.setDraggable(index);\n        }\n    },\n    beforeUnmount() {\n        if (!this.disabled)\n            this.removeDraggable();\n    },\n    methods: {\n        setDraggable(index) {\n            const node = this.$el;\n            node.sortableInfo = {\n                index,\n                manager: this.manager,\n            };\n            this.ref = { node };\n            this.manager.add(this.ref);\n        },\n        removeDraggable() {\n            this.manager.remove(this.ref);\n        },\n    },\n});\n\nclass Manager {\n    constructor() {\n        this.refs = [];\n        this.active = null;\n    }\n    add(ref) {\n        if (!this.refs) {\n            this.refs = [];\n        }\n        this.refs.push(ref);\n    }\n    remove(ref) {\n        const index = this.getIndex(ref);\n        if (index !== -1) {\n            this.refs.splice(index, 1);\n        }\n    }\n    isActive() {\n        return !!this.active;\n    }\n    getActive() {\n        return this.refs.find(({ node }) => { var _a, _b; return ((_a = node === null || node === void 0 ? void 0 : node.sortableInfo) === null || _a === void 0 ? void 0 : _a.index) == ((_b = this === null || this === void 0 ? void 0 : this.active) === null || _b === void 0 ? void 0 : _b.index); }) || null;\n    }\n    getIndex(ref) {\n        return this.refs.indexOf(ref);\n    }\n    getRefs() {\n        return this.refs;\n    }\n    getOrderedRefs() {\n        return this.refs.sort((a, b) => {\n            return a.node.sortableInfo.index - b.node.sortableInfo.index;\n        });\n    }\n}\n\nconst isTouch = (e) => {\n    return e.touches != null;\n};\n// eslint-disable-next-line @typescript-eslint/ban-types\nfunction hasOwnProperty(obj, prop) {\n    return !!obj && Object.prototype.hasOwnProperty.call(obj, prop);\n}\nfunction arrayMove(arr, previousIndex, newIndex) {\n    const array = arr.slice(0);\n    if (newIndex >= array.length) {\n        let k = newIndex - array.length;\n        while (k-- + 1) {\n            array.push(undefined);\n        }\n    }\n    array.splice(newIndex, 0, array.splice(previousIndex, 1)[0]);\n    return array;\n}\nfunction arrayRemove(arr, previousIndex) {\n    const array = arr.slice(0);\n    if (previousIndex >= array.length)\n        return array;\n    array.splice(previousIndex, 1);\n    return array;\n}\nfunction arrayInsert(arr, newIndex, value) {\n    const array = arr.slice(0);\n    if (newIndex === array.length) {\n        array.push(value);\n    }\n    else {\n        array.splice(newIndex, 0, value);\n    }\n    return array;\n}\nconst events = {\n    start: ['touchstart', 'mousedown'],\n    move: ['touchmove', 'mousemove'],\n    end: ['touchend', 'mouseup'],\n    cancel: ['touchcancel', 'keyup'],\n};\nfunction closest(el, fn) {\n    while (el) {\n        if (fn(el))\n            return el;\n        el = el.parentNode;\n    }\n}\nfunction limit(min, max, value) {\n    if (value < min) {\n        return min;\n    }\n    if (value > max) {\n        return max;\n    }\n    return value;\n}\nfunction getCSSPixelValue(stringValue) {\n    if (stringValue.substr(-2) === 'px') {\n        return parseFloat(stringValue);\n    }\n    return 0;\n}\nfunction getElementMargin(element) {\n    const style = window.getComputedStyle(element);\n    return {\n        top: getCSSPixelValue(style.marginTop),\n        right: getCSSPixelValue(style.marginRight),\n        bottom: getCSSPixelValue(style.marginBottom),\n        left: getCSSPixelValue(style.marginLeft),\n    };\n}\nfunction getPointerOffset(e, reference = 'page') {\n    const x = `${reference}X`;\n    const y = `${reference}Y`;\n    return {\n        x: isTouch(e) ? e.touches[0][x] : e[x],\n        y: isTouch(e) ? e.touches[0][y] : e[y],\n    };\n}\nfunction offsetParents(node) {\n    const nodes = [node];\n    for (; node; node = node.offsetParent) {\n        nodes.unshift(node);\n    }\n    return nodes;\n}\nfunction commonOffsetParent(node1, node2) {\n    const parents1 = offsetParents(node1);\n    const parents2 = offsetParents(node2);\n    if (parents1[0] != parents2[0])\n        throw 'No common ancestor!';\n    for (let i = 0; i < parents1.length; i++) {\n        if (parents1[i] != parents2[i])\n            return parents1[i - 1];\n    }\n}\nfunction getEdgeOffset(node, container, offset = { top: 0, left: 0 }) {\n    // Get the actual offsetTop / offsetLeft value, no matter how deep the node is nested\n    if (node) {\n        const nodeOffset = {\n            top: offset.top + node.offsetTop,\n            left: offset.left + node.offsetLeft,\n        };\n        if (node.offsetParent !== container.offsetParent) {\n            return getEdgeOffset(node.offsetParent, container, nodeOffset);\n        }\n        else {\n            return nodeOffset;\n        }\n    }\n    return { top: 0, left: 0 };\n}\nfunction cloneNode(node) {\n    const fields = node.querySelectorAll('input, textarea, select');\n    const clonedNode = node.cloneNode(true);\n    const clonedFields = [...clonedNode.querySelectorAll('input, textarea, select')]; // Convert NodeList to Array\n    clonedFields.forEach((field, index) => {\n        if (field.type !== 'file' && fields[index]) {\n            field.value = fields[index].value;\n        }\n    });\n    return clonedNode;\n}\nfunction getLockPixelOffsets(lockOffset, width, height) {\n    if (typeof lockOffset == 'string') {\n        lockOffset = +lockOffset;\n    }\n    if (!Array.isArray(lockOffset)) {\n        lockOffset = [lockOffset, lockOffset];\n    }\n    if (lockOffset.length !== 2) {\n        throw new Error(`lockOffset prop of SortableContainer should be a single value or an array of exactly two values. Given ${lockOffset}`);\n    }\n    const [minLockOffset, maxLockOffset] = lockOffset;\n    return [getLockPixelOffset(minLockOffset, width, height), getLockPixelOffset(maxLockOffset, width, height)];\n}\nfunction getLockPixelOffset(lockOffset, width, height) {\n    let offsetX = lockOffset;\n    let offsetY = lockOffset;\n    let unit = 'px';\n    if (typeof lockOffset === 'string') {\n        const match = /^[+-]?\\d*(?:\\.\\d*)?(px|%)$/.exec(lockOffset);\n        if (match === null) {\n            throw new Error(`lockOffset value should be a number or a string of a number followed by \"px\" or \"%\". Given ${lockOffset}`);\n        }\n        offsetX = offsetY = parseFloat(lockOffset);\n        unit = match[1];\n    }\n    if (!isFinite(offsetX) || !isFinite(offsetY)) {\n        throw new Error(`lockOffset value should be a finite. Given ${lockOffset}`);\n    }\n    if (unit === '%') {\n        offsetX = (offsetX * width) / 100;\n        offsetY = (offsetY * height) / 100;\n    }\n    return {\n        x: offsetX,\n        y: offsetY,\n    };\n}\nfunction getDistance(x1, y1, x2, y2) {\n    const x = x1 - x2;\n    const y = y1 - y2;\n    return Math.sqrt(x * x + y * y);\n}\nfunction getRectCenter(clientRect) {\n    return {\n        x: clientRect.left + clientRect.width / 2,\n        y: clientRect.top + clientRect.height / 2,\n    };\n}\nfunction resetTransform(nodes = []) {\n    for (let i = 0, len = nodes.length; i < len; i++) {\n        const node = nodes[i];\n        const el = node.node;\n        if (!el)\n            return;\n        // Clear the cached offsetTop / offsetLeft value\n        node.edgeOffset = null;\n        // Remove the transforms / transitions\n        setTransform(el);\n    }\n}\nfunction setTransform(el, transform = '', duration = '') {\n    if (!el)\n        return;\n    el.style['transform'] = transform;\n    el.style['transitionDuration'] = duration;\n}\nfunction withinBounds(pos, top, bottom) {\n    const upper = Math.max(top, bottom);\n    const lower = Math.min(top, bottom);\n    return lower <= pos && pos <= upper;\n}\nfunction isPointWithinRect({ x, y }, { top, left, width, height }) {\n    const withinX = withinBounds(x, left, left + width);\n    const withinY = withinBounds(y, top, top + height);\n    return withinX && withinY;\n}\n\n/* eslint-disable @typescript-eslint/ban-ts-comment */\n// eslint-disable-next-line @typescript-eslint/ban-types\nconst timeout = setTimeout;\n// Export Sortable Container Component Mixin\nconst ContainerMixin = defineComponent({\n    inject: {\n        SlicksortHub: {\n            from: 'SlicksortHub',\n            default: null,\n        },\n    },\n    provide() {\n        return {\n            manager: this.manager,\n        };\n    },\n    props: {\n        list: { type: Array, required: true },\n        axis: { type: String, default: 'y' },\n        distance: { type: Number, default: 0 },\n        pressDelay: { type: Number, default: 0 },\n        pressThreshold: { type: Number, default: 5 },\n        useDragHandle: { type: Boolean, default: false },\n        useWindowAsScrollContainer: { type: Boolean, default: false },\n        hideSortableGhost: { type: Boolean, default: true },\n        lockToContainerEdges: { type: Boolean, default: false },\n        lockOffset: { type: [String, Number, Array], default: '50%' },\n        transitionDuration: { type: Number, default: 300 },\n        appendTo: { type: String, default: 'body' },\n        draggedSettlingDuration: { type: Number, default: null },\n        group: { type: String, default: '' },\n        accept: { type: [Boolean, Array, Function], default: null },\n        cancelKey: { type: String, default: 'Escape' },\n        block: { type: Array, default: () => [] },\n        lockAxis: { type: String, default: '' },\n        helperClass: { type: String, default: '' },\n        contentWindow: { type: Object, default: null },\n        shouldCancelStart: {\n            type: Function,\n            default: (e) => {\n                // Cancel sorting if the event target is an `input`, `textarea`, `select` or `option`\n                const disabledElements = ['input', 'textarea', 'select', 'option', 'button'];\n                return disabledElements.indexOf(e.target.tagName.toLowerCase()) !== -1;\n            },\n        },\n        getHelperDimensions: {\n            type: Function,\n            default: ({ node }) => ({\n                width: node.offsetWidth,\n                height: node.offsetHeight,\n            }),\n        },\n    },\n    emits: ['sort-start', 'sort-move', 'sort-end', 'sort-cancel', 'sort-insert', 'sort-remove', 'update:list'],\n    data() {\n        let useHub = false;\n        if (this.group) {\n            // If the group option is set, it is assumed the user intends\n            // to drag between containers and the required plugin has been installed\n            if (this.SlicksortHub) {\n                useHub = true;\n            }\n            else if (process.env.NODE_ENV !== 'production') {\n                throw new Error('Slicksort plugin required to use \"group\" prop');\n            }\n        }\n        return {\n            sorting: false,\n            hub: useHub ? this.SlicksortHub : null,\n            manager: new Manager(),\n        };\n    },\n    mounted() {\n        if (this.hub) {\n            this.id = this.hub.getId();\n        }\n        this.container = this.$el;\n        this.document = this.container.ownerDocument || document;\n        this._window = this.contentWindow || window;\n        this.scrollContainer = this.useWindowAsScrollContainer ? { scrollLeft: 0, scrollTop: 0 } : this.container;\n        this.events = {\n            start: this.handleStart,\n            move: this.handleMove,\n            end: this.handleEnd,\n        };\n        for (const key in this.events) {\n            if (hasOwnProperty(this.events, key)) {\n                // @ts-ignore\n                events[key].forEach((eventName) => this.container.addEventListener(eventName, this.events[key]));\n            }\n        }\n        if (this.hub) {\n            this.hub.addContainer(this);\n        }\n    },\n    beforeUnmount() {\n        for (const key in this.events) {\n            if (hasOwnProperty(this.events, key)) {\n                // @ts-ignore\n                events[key].forEach((eventName) => this.container.removeEventListener(eventName, this.events[key]));\n            }\n        }\n        if (this.hub) {\n            this.hub.removeContainer(this);\n        }\n        if (this.dragendTimer)\n            clearTimeout(this.dragendTimer);\n        if (this.cancelTimer)\n            clearTimeout(this.cancelTimer);\n        if (this.pressTimer)\n            clearTimeout(this.pressTimer);\n        if (this.autoscrollInterval)\n            clearInterval(this.autoscrollInterval);\n    },\n    methods: {\n        handleStart(e) {\n            const { distance, shouldCancelStart } = this.$props;\n            if ((!isTouch(e) && e.button === 2) || shouldCancelStart(e)) {\n                return false;\n            }\n            this._touched = true;\n            this._pos = getPointerOffset(e);\n            const target = e.target;\n            const node = closest(target, (el) => el.sortableInfo != null);\n            if (node && node.sortableInfo && this.nodeIsChild(node) && !this.sorting) {\n                const { useDragHandle } = this.$props;\n                const { index } = node.sortableInfo;\n                if (useDragHandle && !closest(target, (el) => el.sortableHandle != null))\n                    return;\n                this.manager.active = { index };\n                /*\n                 * Fixes a bug in Firefox where the :active state of anchor tags\n                 * prevent subsequent 'mousemove' events from being fired\n                 * (see https://github.com/clauderic/react-sortable-hoc/issues/118)\n                 */\n                if (target.tagName.toLowerCase() === 'a') {\n                    e.preventDefault();\n                }\n                if (!distance) {\n                    if (this.pressDelay === 0) {\n                        this.handlePress(e);\n                    }\n                    else {\n                        this.pressTimer = timeout(() => this.handlePress(e), this.pressDelay);\n                    }\n                }\n            }\n        },\n        nodeIsChild(node) {\n            return node.sortableInfo.manager === this.manager;\n        },\n        handleMove(e) {\n            const { distance, pressThreshold } = this.$props;\n            if (!this.sorting && this._touched) {\n                const offset = getPointerOffset(e);\n                this._delta = {\n                    x: this._pos.x - offset.x,\n                    y: this._pos.y - offset.y,\n                };\n                const delta = Math.abs(this._delta.x) + Math.abs(this._delta.y);\n                if (!distance && (!pressThreshold || (pressThreshold && delta >= pressThreshold))) {\n                    if (this.cancelTimer)\n                        clearTimeout(this.cancelTimer);\n                    this.cancelTimer = timeout(this.cancel, 0);\n                }\n                else if (distance && delta >= distance && this.manager.isActive()) {\n                    this.handlePress(e);\n                }\n            }\n        },\n        handleEnd() {\n            if (!this._touched)\n                return;\n            const { distance } = this.$props;\n            this._touched = false;\n            if (!distance) {\n                this.cancel();\n            }\n        },\n        cancel() {\n            if (!this.sorting) {\n                if (this.pressTimer)\n                    clearTimeout(this.pressTimer);\n                this.manager.active = null;\n                if (this.hub)\n                    this.hub.cancel();\n            }\n        },\n        handleSortCancel(e) {\n            if (isTouch(e) || e.key === this.cancelKey) {\n                this.newIndex = this.index;\n                this.canceling = true;\n                this.translate = { x: 0, y: 0 };\n                this.animateNodes();\n                this.handleSortEnd(e);\n            }\n        },\n        handlePress(e) {\n            e.stopPropagation();\n            const active = this.manager.getActive();\n            if (active) {\n                const { getHelperDimensions, helperClass, hideSortableGhost, appendTo } = this.$props;\n                const { node } = active;\n                const { index } = node.sortableInfo;\n                const margin = getElementMargin(node);\n                const containerBoundingRect = this.container.getBoundingClientRect();\n                const dimensions = getHelperDimensions({ index, node });\n                this.node = node;\n                this.margin = margin;\n                this.width = dimensions.width;\n                this.height = dimensions.height;\n                this.marginOffset = {\n                    x: this.margin.left + this.margin.right,\n                    y: Math.max(this.margin.top, this.margin.bottom),\n                };\n                this.boundingClientRect = node.getBoundingClientRect();\n                this.containerBoundingRect = containerBoundingRect;\n                this.index = index;\n                this.newIndex = index;\n                const clonedNode = cloneNode(node);\n                this.helper = this.document.querySelector(appendTo).appendChild(clonedNode);\n                this.helper.style.position = 'fixed';\n                this.helper.style.top = `${this.boundingClientRect.top - margin.top}px`;\n                this.helper.style.left = `${this.boundingClientRect.left - margin.left}px`;\n                this.helper.style.width = `${this.width}px`;\n                this.helper.style.height = `${this.height}px`;\n                this.helper.style.boxSizing = 'border-box';\n                this.helper.style.pointerEvents = 'none';\n                if (hideSortableGhost) {\n                    this.sortableGhost = node;\n                    node.style.visibility = 'hidden';\n                    node.style.opacity = '0';\n                }\n                if (this.hub) {\n                    this.hub.sortStart(this);\n                    this.hub.helper = this.helper;\n                    this.hub.ghost = this.sortableGhost;\n                }\n                this.intializeOffsets(e, this.boundingClientRect);\n                this.offsetEdge = getEdgeOffset(node, this.container);\n                if (helperClass) {\n                    this.helper.classList.add(...helperClass.split(' '));\n                }\n                this.listenerNode = isTouch(e) ? node : this._window;\n                // @ts-ignore\n                events.move.forEach((eventName) => this.listenerNode.addEventListener(eventName, this.handleSortMove));\n                // @ts-ignore\n                events.end.forEach((eventName) => this.listenerNode.addEventListener(eventName, this.handleSortEnd));\n                // @ts-ignore\n                events.cancel.forEach((eventName) => this.listenerNode.addEventListener(eventName, this.handleSortCancel));\n                this.sorting = true;\n                this.$emit('sort-start', { event: e, node, index });\n            }\n        },\n        handleSortMove(e) {\n            e.preventDefault(); // Prevent scrolling on mobile\n            this.updatePosition(e);\n            if (this.hub) {\n                const payload = this.list[this.index];\n                this.hub.handleSortMove(e, payload);\n            }\n            if (!this.hub || this.hub.isDest(this)) {\n                this.animateNodes();\n                this.autoscroll();\n            }\n            this.$emit('sort-move', { event: e });\n        },\n        handleDropOut() {\n            const removed = this.list[this.index];\n            const newValue = arrayRemove(this.list, this.index);\n            this.$emit('sort-remove', {\n                oldIndex: this.index,\n            });\n            this.$emit('update:list', newValue);\n            return removed;\n        },\n        handleDropIn(payload) {\n            const newValue = arrayInsert(this.list, this.newIndex, payload);\n            this.$emit('sort-insert', {\n                newIndex: this.newIndex,\n                value: payload,\n            });\n            this.$emit('update:list', newValue);\n            this.handleDragEnd();\n        },\n        handleDragOut() {\n            if (this.autoscrollInterval) {\n                clearInterval(this.autoscrollInterval);\n                this.autoscrollInterval = null;\n            }\n            if (this.hub.isSource(this)) {\n                // Trick to animate all nodes up\n                this.translate = {\n                    x: 10000,\n                    y: 10000,\n                };\n                this.animateNodes();\n            }\n            else {\n                this.manager.getRefs().forEach((ref) => {\n                    ref.node.style['transform'] = '';\n                });\n                this.dragendTimer = timeout(this.handleDragEnd, this.transitionDuration || 0);\n            }\n        },\n        handleDragEnd() {\n            if (this.autoscrollInterval) {\n                clearInterval(this.autoscrollInterval);\n                this.autoscrollInterval = null;\n            }\n            resetTransform(this.manager.getRefs());\n            if (this.sortableGhost) {\n                this.sortableGhost.remove();\n                this.sortableGhost = null;\n            }\n            if (this.dragendTimer) {\n                clearTimeout(this.dragendTimer);\n                this.dragendTimer = null;\n            }\n            this.manager.active = null;\n            this._touched = false;\n            this.sorting = false;\n        },\n        intializeOffsets(e, clientRect) {\n            const { useWindowAsScrollContainer, containerBoundingRect, _window } = this;\n            this.marginOffset = {\n                x: this.margin.left + this.margin.right,\n                y: Math.max(this.margin.top, this.margin.bottom),\n            };\n            this._axis = {\n                x: this.axis.indexOf('x') >= 0,\n                y: this.axis.indexOf('y') >= 0,\n            };\n            this.initialOffset = getPointerOffset(e);\n            // initialScroll;\n            this.initialScroll = {\n                top: this.scrollContainer.scrollTop,\n                left: this.scrollContainer.scrollLeft,\n            };\n            // initialWindowScroll;\n            this.initialWindowScroll = {\n                top: window.pageYOffset,\n                left: window.pageXOffset,\n            };\n            this.translate = { x: 0, y: 0 };\n            this.minTranslate = {};\n            this.maxTranslate = {};\n            if (this._axis.x) {\n                this.minTranslate.x =\n                    (useWindowAsScrollContainer ? 0 : containerBoundingRect.left) - clientRect.left - this.width / 2;\n                this.maxTranslate.x =\n                    (useWindowAsScrollContainer ? _window.innerWidth : containerBoundingRect.left + containerBoundingRect.width) -\n                        clientRect.left -\n                        this.width / 2;\n            }\n            if (this._axis.y) {\n                this.minTranslate.y =\n                    (useWindowAsScrollContainer ? 0 : containerBoundingRect.top) - clientRect.top - this.height / 2;\n                this.maxTranslate.y =\n                    (useWindowAsScrollContainer\n                        ? _window.innerHeight\n                        : containerBoundingRect.top + containerBoundingRect.height) -\n                        clientRect.top -\n                        this.height / 2;\n            }\n        },\n        handleDragIn(e, sortableGhost, helper) {\n            if (this.hub.isSource(this)) {\n                return;\n            }\n            if (this.dragendTimer) {\n                this.handleDragEnd();\n                clearTimeout(this.dragendTimer);\n                this.dragendTimer = null;\n            }\n            const nodes = this.manager.getRefs();\n            this.index = nodes.length;\n            this.manager.active = { index: this.index };\n            const containerBoundingRect = this.container.getBoundingClientRect();\n            const helperBoundingRect = helper.getBoundingClientRect();\n            this.containerBoundingRect = containerBoundingRect;\n            this.sortableGhost = cloneNode(sortableGhost);\n            this.container.appendChild(this.sortableGhost);\n            const ghostRect = this.sortableGhost.getBoundingClientRect();\n            this.boundingClientRect = ghostRect;\n            this.margin = getElementMargin(this.sortableGhost);\n            this.width = ghostRect.width;\n            this.height = ghostRect.height;\n            // XY coords of the inserted node, relative to the top-left corner of the container\n            this.offsetEdge = getEdgeOffset(this.sortableGhost, this.container);\n            this.intializeOffsets(e, ghostRect);\n            // Move the initialOffset back to the insertion point of the\n            // sortableGhost (end of the list), as if we had started the drag there.\n            this.initialOffset.x += ghostRect.x - helperBoundingRect.x;\n            this.initialOffset.y += ghostRect.y - helperBoundingRect.y;\n            // Turn on dragging\n            this.sorting = true;\n        },\n        handleSortEnd(e) {\n            // Remove the event listeners if the node is still in the DOM\n            if (this.listenerNode) {\n                events.move.forEach((eventName) => \n                // @ts-ignore\n                this.listenerNode.removeEventListener(eventName, this.handleSortMove));\n                events.end.forEach((eventName) => \n                // @ts-ignore\n                this.listenerNode.removeEventListener(eventName, this.handleSortEnd));\n                events.cancel.forEach((eventName) => \n                // @ts-ignore\n                this.listenerNode.removeEventListener(eventName, this.handleSortCancel));\n            }\n            const nodes = this.manager.getRefs();\n            // Remove the helper class(es) early to give it a chance to transition back\n            if (this.helper && this.helperClass) {\n                this.helper.classList.remove(...this.helperClass.split(' '));\n            }\n            // Stop autoscroll\n            if (this.autoscrollInterval)\n                clearInterval(this.autoscrollInterval);\n            this.autoscrollInterval = null;\n            const onEnd = () => {\n                // Remove the helper from the DOM\n                if (this.helper) {\n                    this.helper.remove();\n                    this.helper = null;\n                }\n                if (this.hideSortableGhost && this.sortableGhost) {\n                    this.sortableGhost.style.visibility = '';\n                    this.sortableGhost.style.opacity = '';\n                }\n                resetTransform(nodes);\n                // Update state\n                if (this.hub && !this.hub.isDest(this)) {\n                    this.canceling ? this.hub.cancel() : this.hub.handleSortEnd();\n                }\n                else if (this.canceling) {\n                    this.$emit('sort-cancel', { event: e });\n                }\n                else {\n                    this.$emit('sort-end', {\n                        event: e,\n                        oldIndex: this.index,\n                        newIndex: this.newIndex,\n                    });\n                    this.$emit('update:list', arrayMove(this.list, this.index, this.newIndex));\n                }\n                this.manager.active = null;\n                this._touched = false;\n                this.canceling = false;\n                this.sorting = false;\n            };\n            if (this.transitionDuration || this.draggedSettlingDuration) {\n                this.transitionHelperIntoPlace(nodes, onEnd);\n            }\n            else {\n                onEnd();\n            }\n        },\n        transitionHelperIntoPlace(nodes, cb) {\n            if (this.draggedSettlingDuration === 0 || nodes.length === 0 || !this.helper) {\n                return Promise.resolve();\n            }\n            const indexNode = nodes[this.index].node;\n            let targetX = 0;\n            let targetY = 0;\n            const scrollDifference = {\n                top: window.pageYOffset - this.initialWindowScroll.top,\n                left: window.pageXOffset - this.initialWindowScroll.left,\n            };\n            if (this.hub && !this.hub.isDest(this) && !this.canceling) {\n                const dest = this.hub.getDest();\n                if (!dest)\n                    return;\n                const destIndex = dest.newIndex;\n                const destRefs = dest.manager.getOrderedRefs();\n                const destNode = destIndex < destRefs.length ? destRefs[destIndex].node : dest.sortableGhost;\n                const ancestor = commonOffsetParent(indexNode, destNode);\n                const sourceOffset = getEdgeOffset(indexNode, ancestor);\n                const targetOffset = getEdgeOffset(destNode, ancestor);\n                targetX = targetOffset.left - sourceOffset.left - scrollDifference.left;\n                targetY = targetOffset.top - sourceOffset.top - scrollDifference.top;\n            }\n            else {\n                const newIndexNode = nodes[this.newIndex].node;\n                const deltaScroll = {\n                    left: this.scrollContainer.scrollLeft - this.initialScroll.left + scrollDifference.left,\n                    top: this.scrollContainer.scrollTop - this.initialScroll.top + scrollDifference.top,\n                };\n                targetX = -deltaScroll.left;\n                if (this.translate && this.translate.x > 0) {\n                    // Diff against right edge when moving to the right\n                    targetX +=\n                        newIndexNode.offsetLeft + newIndexNode.offsetWidth - (indexNode.offsetLeft + indexNode.offsetWidth);\n                }\n                else {\n                    targetX += newIndexNode.offsetLeft - indexNode.offsetLeft;\n                }\n                targetY = -deltaScroll.top;\n                if (this.translate && this.translate.y > 0) {\n                    // Diff against the bottom edge when moving down\n                    targetY +=\n                        newIndexNode.offsetTop + newIndexNode.offsetHeight - (indexNode.offsetTop + indexNode.offsetHeight);\n                }\n                else {\n                    targetY += newIndexNode.offsetTop - indexNode.offsetTop;\n                }\n            }\n            const duration = this.draggedSettlingDuration !== null ? this.draggedSettlingDuration : this.transitionDuration;\n            setTransform(this.helper, `translate3d(${targetX}px,${targetY}px, 0)`, `${duration}ms`);\n            // Register an event handler to clean up styles when the transition\n            // finishes.\n            const cleanup = (event) => {\n                if (!event || event.propertyName === 'transform') {\n                    clearTimeout(cleanupTimer);\n                    setTransform(this.helper);\n                    cb();\n                }\n            };\n            // Force cleanup in case 'transitionend' never fires\n            const cleanupTimer = setTimeout(cleanup, duration + 10);\n            this.helper.addEventListener('transitionend', cleanup);\n        },\n        updatePosition(e) {\n            const { lockAxis, lockToContainerEdges } = this.$props;\n            const offset = getPointerOffset(e);\n            const translate = {\n                x: offset.x - this.initialOffset.x,\n                y: offset.y - this.initialOffset.y,\n            };\n            // Adjust for window scroll\n            translate.y -= window.pageYOffset - this.initialWindowScroll.top;\n            translate.x -= window.pageXOffset - this.initialWindowScroll.left;\n            this.translate = translate;\n            if (lockToContainerEdges) {\n                const [minLockOffset, maxLockOffset] = getLockPixelOffsets(this.lockOffset, this.height, this.width);\n                const minOffset = {\n                    x: this.width / 2 - minLockOffset.x,\n                    y: this.height / 2 - minLockOffset.y,\n                };\n                const maxOffset = {\n                    x: this.width / 2 - maxLockOffset.x,\n                    y: this.height / 2 - maxLockOffset.y,\n                };\n                if (this.minTranslate.x && this.maxTranslate.x)\n                    translate.x = limit(this.minTranslate.x + minOffset.x, this.maxTranslate.x - maxOffset.x, translate.x);\n                if (this.minTranslate.y && this.maxTranslate.y)\n                    translate.y = limit(this.minTranslate.y + minOffset.y, this.maxTranslate.y - maxOffset.y, translate.y);\n            }\n            if (lockAxis === 'x') {\n                translate.y = 0;\n            }\n            else if (lockAxis === 'y') {\n                translate.x = 0;\n            }\n            if (this.helper) {\n                this.helper.style['transform'] = `translate3d(${translate.x}px,${translate.y}px, 0)`;\n            }\n        },\n        animateNodes() {\n            const { transitionDuration, hideSortableGhost } = this.$props;\n            const nodes = this.manager.getOrderedRefs();\n            const deltaScroll = {\n                left: this.scrollContainer.scrollLeft - this.initialScroll.left,\n                top: this.scrollContainer.scrollTop - this.initialScroll.top,\n            };\n            const sortingOffset = {\n                left: this.offsetEdge.left + this.translate.x + deltaScroll.left,\n                top: this.offsetEdge.top + this.translate.y + deltaScroll.top,\n            };\n            const scrollDifference = {\n                top: window.pageYOffset - this.initialWindowScroll.top,\n                left: window.pageXOffset - this.initialWindowScroll.left,\n            };\n            this.newIndex = null;\n            for (let i = 0, len = nodes.length; i < len; i++) {\n                const { node } = nodes[i];\n                const index = node.sortableInfo.index;\n                const width = node.offsetWidth;\n                const height = node.offsetHeight;\n                const offset = {\n                    width: this.width > width ? width / 2 : this.width / 2,\n                    height: this.height > height ? height / 2 : this.height / 2,\n                };\n                const translate = {\n                    x: 0,\n                    y: 0,\n                };\n                let { edgeOffset } = nodes[i];\n                // If we haven't cached the node's offsetTop / offsetLeft value\n                if (!edgeOffset) {\n                    nodes[i].edgeOffset = edgeOffset = getEdgeOffset(node, this.container);\n                }\n                // Get a reference to the next and previous node\n                const nextNode = i < nodes.length - 1 && nodes[i + 1];\n                const prevNode = i > 0 && nodes[i - 1];\n                // Also cache the next node's edge offset if needed.\n                // We need this for calculating the animation in a grid setup\n                if (nextNode && !nextNode.edgeOffset) {\n                    nextNode.edgeOffset = getEdgeOffset(nextNode.node, this.container);\n                }\n                // If the node is the one we're currently animating, skip it\n                if (index === this.index) {\n                    /*\n                     * With windowing libraries such as `react-virtualized`, the sortableGhost\n                     * node may change while scrolling down and then back up (or vice-versa),\n                     * so we need to update the reference to the new node just to be safe.\n                     */\n                    if (hideSortableGhost) {\n                        this.sortableGhost = node;\n                        node.style.visibility = 'hidden';\n                        node.style.opacity = '0';\n                    }\n                    continue;\n                }\n                if (transitionDuration) {\n                    node.style['transitionDuration'] = `${transitionDuration}ms`;\n                }\n                if (this._axis.x) {\n                    if (this._axis.y) {\n                        // Calculations for a grid setup\n                        if (index < this.index &&\n                            ((sortingOffset.left + scrollDifference.left - offset.width <= edgeOffset.left &&\n                                sortingOffset.top + scrollDifference.top <= edgeOffset.top + offset.height) ||\n                                sortingOffset.top + scrollDifference.top + offset.height <= edgeOffset.top)) {\n                            // If the current node is to the left on the same row, or above the node that's being dragged\n                            // then move it to the right\n                            translate.x = this.width + this.marginOffset.x;\n                            if (edgeOffset.left + translate.x > this.containerBoundingRect.width - offset.width && nextNode) {\n                                // If it moves passed the right bounds, then animate it to the first position of the next row.\n                                // We just use the offset of the next node to calculate where to move, because that node's original position\n                                // is exactly where we want to go\n                                translate.x = nextNode.edgeOffset.left - edgeOffset.left;\n                                translate.y = nextNode.edgeOffset.top - edgeOffset.top;\n                            }\n                            if (this.newIndex === null) {\n                                this.newIndex = index;\n                            }\n                        }\n                        else if (index > this.index &&\n                            ((sortingOffset.left + scrollDifference.left + offset.width >= edgeOffset.left &&\n                                sortingOffset.top + scrollDifference.top + offset.height >= edgeOffset.top) ||\n                                sortingOffset.top + scrollDifference.top + offset.height >= edgeOffset.top + height)) {\n                            // If the current node is to the right on the same row, or below the node that's being dragged\n                            // then move it to the left\n                            translate.x = -(this.width + this.marginOffset.x);\n                            if (edgeOffset.left + translate.x < this.containerBoundingRect.left + offset.width && prevNode) {\n                                // If it moves passed the left bounds, then animate it to the last position of the previous row.\n                                // We just use the offset of the previous node to calculate where to move, because that node's original position\n                                // is exactly where we want to go\n                                translate.x = prevNode.edgeOffset.left - edgeOffset.left;\n                                translate.y = prevNode.edgeOffset.top - edgeOffset.top;\n                            }\n                            this.newIndex = index;\n                        }\n                    }\n                    else {\n                        if (index > this.index && sortingOffset.left + scrollDifference.left + offset.width >= edgeOffset.left) {\n                            translate.x = -(this.width + this.marginOffset.x);\n                            this.newIndex = index;\n                        }\n                        else if (index < this.index &&\n                            sortingOffset.left + scrollDifference.left <= edgeOffset.left + offset.width) {\n                            translate.x = this.width + this.marginOffset.x;\n                            if (this.newIndex == null) {\n                                this.newIndex = index;\n                            }\n                        }\n                    }\n                }\n                else if (this._axis.y) {\n                    if (index > this.index && sortingOffset.top + scrollDifference.top + offset.height >= edgeOffset.top) {\n                        translate.y = -(this.height + this.marginOffset.y);\n                        this.newIndex = index;\n                    }\n                    else if (index < this.index &&\n                        sortingOffset.top + scrollDifference.top <= edgeOffset.top + offset.height) {\n                        translate.y = this.height + this.marginOffset.y;\n                        if (this.newIndex == null) {\n                            this.newIndex = index;\n                        }\n                    }\n                }\n                node.style['transform'] = `translate3d(${translate.x}px,${translate.y}px,0)`;\n            }\n            if (this.newIndex == null) {\n                this.newIndex = this.index;\n            }\n        },\n        autoscroll() {\n            const translate = this.translate;\n            const direction = {\n                x: 0,\n                y: 0,\n            };\n            const speed = {\n                x: 1,\n                y: 1,\n            };\n            const acceleration = {\n                x: 10,\n                y: 10,\n            };\n            if (translate.y >= this.maxTranslate.y - this.height / 2) {\n                direction.y = 1; // Scroll Down\n                speed.y = acceleration.y * Math.abs((this.maxTranslate.y - this.height / 2 - translate.y) / this.height);\n            }\n            else if (translate.x >= this.maxTranslate.x - this.width / 2) {\n                direction.x = 1; // Scroll Right\n                speed.x = acceleration.x * Math.abs((this.maxTranslate.x - this.width / 2 - translate.x) / this.width);\n            }\n            else if (translate.y <= this.minTranslate.y + this.height / 2) {\n                direction.y = -1; // Scroll Up\n                speed.y = acceleration.y * Math.abs((translate.y - this.height / 2 - this.minTranslate.y) / this.height);\n            }\n            else if (translate.x <= this.minTranslate.x + this.width / 2) {\n                direction.x = -1; // Scroll Left\n                speed.x = acceleration.x * Math.abs((translate.x - this.width / 2 - this.minTranslate.x) / this.width);\n            }\n            if (this.autoscrollInterval) {\n                clearInterval(this.autoscrollInterval);\n                this.autoscrollInterval = null;\n            }\n            if (direction.x !== 0 || direction.y !== 0) {\n                this.autoscrollInterval = window.setInterval(() => {\n                    const offset = {\n                        left: 1 * speed.x * direction.x,\n                        top: 1 * speed.y * direction.y,\n                    };\n                    if (this.useWindowAsScrollContainer) {\n                        this._window.scrollBy(offset.left, offset.top);\n                    }\n                    else {\n                        this.scrollContainer.scrollTop += offset.top;\n                        this.scrollContainer.scrollLeft += offset.left;\n                    }\n                    this.translate.x += offset.left;\n                    this.translate.y += offset.top;\n                    this.animateNodes();\n                }, 5);\n            }\n        },\n    },\n});\n\n// Export Sortable Element Handle Directive\nconst HandleDirective = {\n    beforeMount(el) {\n        el.sortableHandle = true;\n    },\n};\n\nconst SlickItem = defineComponent({\n    name: 'SlickItem',\n    mixins: [ElementMixin],\n    props: {\n        tag: {\n            type: String,\n            default: 'div',\n        },\n    },\n    render() {\n        var _a, _b;\n        return h(this.tag, (_b = (_a = this.$slots).default) === null || _b === void 0 ? void 0 : _b.call(_a));\n    },\n});\n\nconst SlickList = defineComponent({\n    name: 'SlickList',\n    mixins: [ContainerMixin],\n    props: {\n        tag: {\n            type: String,\n            default: 'div',\n        },\n        itemKey: {\n            type: [String, Function],\n            default: 'id',\n        },\n    },\n    render() {\n        var _a, _b;\n        if (this.$slots.item) {\n            return h(this.tag, this.list.map((item, index) => {\n                let key;\n                if (item == null) {\n                    return;\n                }\n                else if (typeof this.itemKey === 'function') {\n                    key = this.itemKey(item);\n                }\n                else if (typeof item === 'object' &&\n                    hasOwnProperty(item, this.itemKey) &&\n                    typeof item[this.itemKey] == 'string') {\n                    key = item[this.itemKey];\n                }\n                else if (typeof item === 'string') {\n                    key = item;\n                }\n                else {\n                    throw new Error('Cannot find key for item, use the item-key prop and pass a function or string');\n                }\n                return h(SlickItem, {\n                    key,\n                    index,\n                }, {\n                    default: () => { var _a, _b; return (_b = (_a = this.$slots).item) === null || _b === void 0 ? void 0 : _b.call(_a, { item, index }); },\n                });\n            }));\n        }\n        return h(this.tag, (_b = (_a = this.$slots).default) === null || _b === void 0 ? void 0 : _b.call(_a));\n    },\n});\n\nconst DragHandle = defineComponent({\n    props: {\n        tag: {\n            type: String,\n            default: 'span',\n        },\n    },\n    mounted() {\n        this.$el.sortableHandle = true;\n    },\n    render() {\n        var _a, _b;\n        return h(this.tag, (_b = (_a = this.$slots).default) === null || _b === void 0 ? void 0 : _b.call(_a));\n    },\n});\n\nlet containerIDCounter = 1;\n/**\n * Always allow when dest === source\n * Defer to 'dest.accept()' if it is a function\n * Allow any group in the accept lists\n * Deny any group in the block list\n * Allow the same group by default, this can be overridden with the block prop\n */\nfunction canAcceptElement(dest, source, payload) {\n    if (source.id === dest.id)\n        return true;\n    if (dest.block && dest.block.includes(source.group))\n        return false;\n    if (typeof dest.accept === 'function') {\n        return dest.accept({ dest, source, payload });\n    }\n    if (typeof dest.accept === 'boolean') {\n        return dest.accept;\n    }\n    if (dest.accept && dest.accept.includes(source.group))\n        return true;\n    if (dest.group === source.group)\n        return true;\n    return false;\n}\nfunction findClosestDest({ x, y }, refs, currentDest) {\n    // Quickly check if we are within the bounds of the current destination\n    if (isPointWithinRect({ x, y }, currentDest.container.getBoundingClientRect())) {\n        return currentDest;\n    }\n    let closest = null;\n    let minDistance = Infinity;\n    for (let i = 0; i < refs.length; i++) {\n        const ref = refs[i];\n        const rect = ref.container.getBoundingClientRect();\n        const isWithin = isPointWithinRect({ x, y }, rect);\n        if (isWithin) {\n            // If we are within another destination, stop here\n            return ref;\n        }\n        const center = getRectCenter(rect);\n        const distance = getDistance(x, y, center.x, center.y);\n        if (distance < minDistance) {\n            closest = ref;\n            minDistance = distance;\n        }\n    }\n    // Try to guess the closest destination\n    return closest;\n}\nclass SlicksortHub {\n    constructor() {\n        this.helper = null;\n        this.ghost = null;\n        this.refs = [];\n        this.source = null;\n        this.dest = null;\n    }\n    getId() {\n        return '' + containerIDCounter++;\n    }\n    isSource({ id }) {\n        var _a;\n        return ((_a = this.source) === null || _a === void 0 ? void 0 : _a.id) === id;\n    }\n    getSource() {\n        return this.source;\n    }\n    isDest({ id }) {\n        var _a;\n        return ((_a = this.dest) === null || _a === void 0 ? void 0 : _a.id) === id;\n    }\n    getDest() {\n        return this.dest;\n    }\n    addContainer(ref) {\n        this.refs.push(ref);\n    }\n    removeContainer(ref) {\n        this.refs = this.refs.filter((c) => c.id !== ref.id);\n    }\n    sortStart(ref) {\n        this.source = ref;\n        this.dest = ref;\n    }\n    handleSortMove(e, payload) {\n        var _a, _b, _c, _d;\n        const dest = this.dest;\n        const source = this.source;\n        if (!dest || !source)\n            return;\n        const refs = this.refs;\n        const pointer = getPointerOffset(e, 'client');\n        const newDest = findClosestDest(pointer, refs, dest) || dest;\n        if (dest.id !== newDest.id && canAcceptElement(newDest, source, payload)) {\n            this.dest = newDest;\n            dest.handleDragOut();\n            newDest.handleDragIn(e, this.ghost, this.helper);\n        }\n        if (dest.id !== ((_a = this.source) === null || _a === void 0 ? void 0 : _a.id)) {\n            (_b = this.dest) === null || _b === void 0 ? void 0 : _b.updatePosition(e);\n            (_c = this.dest) === null || _c === void 0 ? void 0 : _c.animateNodes();\n            (_d = this.dest) === null || _d === void 0 ? void 0 : _d.autoscroll();\n        }\n    }\n    handleSortEnd() {\n        var _a, _b, _c, _d;\n        if (((_a = this.source) === null || _a === void 0 ? void 0 : _a.id) === ((_b = this.dest) === null || _b === void 0 ? void 0 : _b.id))\n            return;\n        const payload = (_c = this.source) === null || _c === void 0 ? void 0 : _c.handleDropOut();\n        (_d = this.dest) === null || _d === void 0 ? void 0 : _d.handleDropIn(payload);\n        this.reset();\n    }\n    reset() {\n        this.source = null;\n        this.dest = null;\n        this.helper = null;\n        this.ghost = null;\n    }\n    cancel() {\n        var _a;\n        (_a = this.dest) === null || _a === void 0 ? void 0 : _a.handleDragEnd();\n        this.reset();\n    }\n}\n\nconst plugin = {\n    install(app) {\n        app.directive('drag-handle', HandleDirective);\n        app.provide('SlicksortHub', new SlicksortHub());\n    },\n};\n\nexport { ContainerMixin, DragHandle, ElementMixin, HandleDirective, SlickItem, SlickList, arrayMove, plugin };\n"],
  "mappings": "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",
  "names": ["_a", "_b", "closest"]
}
